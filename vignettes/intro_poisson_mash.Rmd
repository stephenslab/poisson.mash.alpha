---
title: "Multi-condition differential expression analysis in single-cell RNA-seq data using Poisson mash"
author: Yusha Liu, Peter Carbonetto
date: "`r Sys.Date()`"
output:
  html_document:
    toc: no
    highlight: textmate
    theme: readable
vignette: >
  %\VignetteIndexEntry{Multi-condition differential expression analysis in single-cell RNA-seq data using Poisson mash}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = "#",collapse = TRUE,results = "hold",
                      fig.align = "center",dpi = 120)
```

Overview
--------

This vignette illustrates how to use
[Poisson multivariate adaptive shrinkage ("Poisson mash")][paper] to
analyze single-cell RNA-sequencing (scRNA-seq) data. Poisson mash was
developed for *multi-condition* differential expression analysis with
scRNA-seq data in which gene expression is measured in many different
conditions. The aim is to detect which genes are differentially
expressed (DE) and to estimate expression differences (log-fold
changes) among multiple conditions. This approach makes use of the
multivariate adaptive shrinkage ([mash][mash]) prior.

We illustrate Poisson mash by analyzing a scRNA-seq data set that was
developed in order to learn about the effects of cytokine stimulation
on gene expression. We will work through the Poisson mash analysis of
this dataa set step-by-step.

First, we load the R packages needed to run the analysis.

```{r load-pkgs, message=FALSE, warning=FALSE}
library(Matrix)
library(scran)
library(glmpca)
library(pheatmap)
library(poisson.mash.alpha)
```

We also set the random number generator seed to ensure that the
results are reproducible.

```{r set-seed}
set.seed(1)
```

Create a data object for Poisson mash
-------------------------------------

To run Poisson mash, you need to provide: (1) a matrix of UMI counts,
stored as a $J \times N$ matrix $Y$ with entries $y_{ji}$, where $i =
1, \dots,N$ indexes cells and $j=1,\dots,J$ indexes genes; and (2) a
vector of length $n$ in which the $i^{\mathrm{th}}$ element gives the
condition label of cell $i$. We denote the number of conditions by
$R$. ($R$ should be much larger than 2.)

The original data set contained counts for 13,362 cells, 8,543 genes
and 45 conditions (44 cytokine treatments plus one control). For this
vignette, we will use subset (1,936 cells, 2,158 genes, 12
conditions), but later we will inspect the results obtained from
running Poisson mash on the full data set.

```{r load-data}
data(neutrophils_subset)
Y <- neutrophils_subset$Y
conditions <- neutrophils_subset$conditions
dim(Y)
conditions <- as.factor(conditions)
table(conditions)
```
 
After loading in the data, we compute the cell-specific size factors.
This can be done in various ways. The simplest option is to take the
sum of the counts $y_{ji}$ across all genes in each cell $i$. Here
we take a deconvolution-based approach implemented in scran:

```{r calculate-size-factor}
clusters  <- quickCluster(Y)
si        <- calculateSumFactors(Y,clusters = clusters)
names(si) <- colnames(Y)
```

Next, we create a data object for poisson mash analysis using the
function `pois_mash_set_data()`.

```{r create-data-object}
dat <- pois_mash_set_data(Y,conditions,si)
```

By default, Poisson mash assumes a gene-specific baseline expression
level, $\mu_j$, that is shared across all conditions.

(Poisson mash can also handle the more complex setting in which the
$R$ conditions arise from $m = 1, \dots, M$ subgroups, and each
subgroup has its own baseline, $\mu_{jm}$. For example, one may want
to perform a DE analysis across multiple treatment conditions, jointly
for multiple cell types. In this case, $M$ is the number of cell
types, and $R$ represents the total number of combinations of
treatment conditions and cell types. Please refer to the documentation
for the function `pois_mash_set_data()` to see how to do this.)

Estimate latent factors capturing unwanted variation
----------------------------------------------------

Unwanted variation present in the data can induce dependence among
gene-wise tests and confound the DE analysis. In some cases, the
confounding variables are known, such as when these capture batch
effects. More often, the unwanted variation is due to unmeasured
factors. Here we estimate the unmeasured confounding variables using
[glmpca][glmpca].

```{r ruv, results="hide", message=FALSE, warning=FALSE}
design <- model.matrix(~conditions)
fit.glmpca <- glmpca(Y = as.matrix(Y),X = design[,-1],L  = 4,fam = "nb2",
                     sz = si,ctl = list(minIter = 1,maxIter = 20,
                                        verbose = TRUE))
Fuv <- as.matrix(fit.glmpca$loadings)
```

For this vignette, we ran `glmpca` for only 20 iterations, but
typically it is better to perform more iterations (100, or perhaps
more).

Fit the Poisson mash model
--------------------------

### Step 1: Prefit the model

We first fit Poisson mash under the assumption of no DE to get
sensible initial estimates of the other model parameters, including
the gene-specific baseline expressions $\mu_j$. (See the
[paper][paper] for details.)

```{r prefit, results="hide"}
prefit <- pois_mash_prefit(dat,ruv = TRUE,Fuv = Fuv,verbose = TRUE)
```

### Step 2: Set up the prior covariance matrices

Let the $R \times 1$ vector $\beta_j = (\beta_{j1}, \dots,
\beta_{jR})'$ denote the true DE effects of each of the $R$ conditions
relative to the baseline expression $\mu_j$ for gene $j$. We assume
that $\beta_j$ follows a "mash prior", which is a mixture of
multivariate normal distributions:
$$
p(\beta_j; \pi, U) =
\sum_{k=1}^K \sum_{l=1}^L \pi_{kl} N_R(\beta_j; 0, w_l U_k).
$$
In the mash prior, $w_l$ is a pre-specified grid of scaling
coefficients, spanning from very small to very large to capture the
full range of possible DE effect sizes; each $U_k$ is a covariance
matrix that captures a different pattern of covariation across
conditions; $\pi_{kl}$ are the mixture proportions that are estimated
from the data during model fitting.

To use Poisson mash, you need to specify these prior covariance
matrices. This may include "canonical" covariance matrices that
represent, for example, DE specific to a condition; and "data-driven"
covariance matrices that are learned from the data and can capture
arbitrary patterns of DE among conditions.

For the canonical matrices, here we consider the matrices capturing
condition-specific effects for each of the $R$ conditions. These
matrices can be generated using the `pois_cov_canonical()` function:

```{r canonical}
ulist.c <- pois_cov_canonical(dat)
```

Data-driven covariance matrices are estimated using a three-step
process: (1) initialization, (2) refinement, (3) diagonal entry
modification. The initialization phase is implemented by the function
`pois_cov_init()`. To estimate the data-driven covariance matrices, we only
use the subset of genes containing "strong signals"; that is, the
genes that are considered DE by a multinomial goodness-of-fit test.
The selection of genes with strong signals is implicitly performed
by the call to `pois_cov_init()`, e.g., setting `cutoff = 3` selects
the genes for which the magnitude of z-score (inverted from the 
p-value of the goodness-of-fit test) exceeds 3. 

```{r cov-init}
res.pca <- pois_cov_init(dat,cutoff = 3)
```

The refinement phase refines the initial estimates of data-driven
covariance matrices using the Extreme Deconvolution (ED) algorithm,
and is implemented by the function `pois_cov_ed()`. As in the
initialization phase, only data from the genes with strong signals are
used. It should be noted that only the data-driven covariance matrices
need to be refined, so they need to be distinguished from the
canonical covariance matrices in the `pois_cov_ed()` call using the
argument `ulist.dd`. 

```{r cov-ed, results="hide"}
R <- ncol(dat$X)
# Merge data-driven and canonical rank-1 prior covariance matrices.
ulist <- c(res.pca$ulist,ulist.c)
# Specify whether a rank-1 prior covariance matrix is data-driven
# or not (note all full-rank covariance matrices are data-driven
# so do not need this specification).
ulist.dd <- c(rep(TRUE,length(res.pca$ulist) - 1),rep(FALSE,R + 1)) 
# Run ED on the genes with strong signals.
fit.ed <- pois_cov_ed(dat,subset = res.pca$subset,Ulist = res.pca$Ulist,
                      ulist = ulist,ulist.dd = ulist.dd,ruv = TRUE,
					  Fuv = Fuv,verbose = TRUE,init = prefit,
					  control = list(maxiter = 10))
```

For the purposes of this vignette, we just ran
`pois_cov_ed()` for 10 iterations, but we recommend performing more
iterations when analyzing your own data (the default number of
iterations is 500).

The modification phase adds a small constant $\epsilon^2$ (e.g.,
0.01) to the diagonal entries of the estimated data-driven covariance
matrices. This step is done to alleviate issues of inflated
[local false sign rates (lfsr)][lfsr] (the lfsr is analogous to but
typically more more conservative than a local false discovery
rate).

```{r cov-mod}
# Add epsilon2*I to each full-rank data-driven prior covariance matrix.
Ulist <- fit.ed$Ulist
H <- length(Ulist)
for(h in 1:H){
  Uh <- Ulist[[h]]
  Uh <- Uh/max(diag(Uh))
  Ulist[[h]] <- Uh + 0.01*diag(R)
}

# Add epsilon2*I to each rank-1 data-driven prior covariance matrix.
G <- length(fit.ed$ulist)
epsilon2.G <- rep(1e-8,G)
names(epsilon2.G) <- names(fit.ed$ulist)
epsilon2.G[ulist.dd] <- 0.01
```

### Step 3: Fit the Poisson mash model

Now we are ready to fit the Poisson mash model to data from all genes,
which is implemented by the function `pois_mash()`.

By default, differences in expression are measured relative to the
mean across all conditions. (To change how expression differences are
measured, see the `pois_mash()` input arguments `C` and
`res.colnames`. See also the `median_deviations` input argument for
computing differences relative to medians as well as means.)

```{r fit-model, results="hide"}
res <- pois_mash(data = dat,Ulist = Ulist,ulist = fit.ed$ulist,
                 ulist.epsilon2 = epsilon2.G,gridmult = 2.5,ruv = TRUE,
				 Fuv = Fuv,rho = prefit$rho,verbose = TRUE,
				 init = list(mu = prefit$mu,psi2 = prefit$psi2),
				 control = list(maxiter = 10,nc = 2)) 
```

For this vignette, we ran `pois_mash()` for only 10 iterations, but 
in practice we recommend setting `maxiter = 100`, or perhaps more.

# Examining the Poisson mash results

Above, we illustrated the steps involved in analyzing scRNA-seq data
using Poisson mash. Separately, we analyzed the full scRNA-seq data
set using
[this script](https://github.com/stephenslab/poisson.mash.alpha/blob/main/inst/code/application_neutrophils.R),
and here we examine the results of this analysis.

```{r load-results}
data(neutrophils_pois_mash_ruv_fit)
```

The output provides posterior summaries of the condition-specific DE
effects relative to the reference condition, including posterior means
and posterior standard deviations of the DE effect sizes (log-fold
changes), and measures of significance (local false sign rates).
These posterior quantities are stored in the "result" output.  For
example, this gives the posterior mean estimates of the log-fold
changes (LFCs):

```{r posterior-mean}
head(neutrophils_pois_mash_ruv_fit$result$PosteriorMean)/log(2)
```

TO DO: Explain that these are differences relative to...?

Here, we divided by `log(2)` to obtain the log-fold changes in the
base-2 logarithm, which is the convention in DE analysis. (The
outputted LFCs are on the natural log-scale.)

These are the local false sign rates (lfsrs) for these LFC estimates:

```{r posterior-lfsr}
head(neutrophils_pois_mash_ruv_fit$result$lfsr)
```
 
We can find the number of DE genes, which are defined as genes having
*lfsr* less than $\alpha$ in at least one condition, where $\alpha$ is a
threshold specified by the user (e.g., 0.05):

```{r find-de}
lfsr <- neutrophils_pois_mash_ruv_fit$result$lfsr
min.lfsr <- apply(lfsr,1,min)
sum(min.lfsr < 0.05)
```

The estimates of other model parameters are stored in the
`pois.mash.fit` component. The the estimated mixture proportions
$\pi_{kl}$ for combinations of different scaling coefficients $w_l$
and prior covariance matrices $U_k$ tell us which sharing patterns
were most prominent in the data:

```{r mixture-proportions, fig.height=5, fig.width=3}
pheatmap(neutrophils_pois_mash_ruv_fit$pois.mash.fit$pi,
         cluster_rows = FALSE,cluster_cols = FALSE,fontsize_row = 6,
		 fontsize_col = 6,main = "")
```

The "tPCA" covariance matrix has by far the largest mixture weight
(91% when summed over all scaling coefficients, i.e., over columns in
this plot).

We plot the correlation heatmap for this covariance matrix, which
captures the most frequent pattern of sharing of DE effects across
cytokine treatments in the neutrophils data. For space reason, here we
present the correlation heatmap only for selected conditions.

```{r plot-sharing-pattern, fig.height=3.5, fig.width=4}
data(condition_colors)
U <- neutrophils_pois_mash_ruv_fit$pois.mash.fit$Ulist$tPCA
colnames(U) <- colnames(neutrophils_pois_mash_ruv_fit$pois.mash.fit$mu)
rownames(U) <- colnames(neutrophils_pois_mash_ruv_fit$pois.mash.fit$mu)
idx.trts <- match(names(condition_colors),
                  colnames(neutrophils_pois_mash_ruv_fit$pois.mash.fit$mu))
corr <- cov2cor(U[idx.trts,idx.trts])
pheatmap(corr,cluster_rows = FALSE,cluster_cols = FALSE,angle_col = 90,
         fontsize = 7,main = "")
```

This correlation heatmap suggests strong sharing of DE effects among
two groups of cytokines: (1) IL-1$\alpha$, IL-1$\beta$, G-CSF and (2)
IL-12 p70, IFN-$\gamma$, IL-18, IL-15, IL-33. We then plot the LFCs
for a few DE genes that either show effect sharing among (1) or (2),
where the reference condition is the mean across all conditions.

Plot a few DE genes that show effect sharing among the first group of
cytokines (taken from Figure 7 in our paper):

```{r plot-lfc-1, fig.height=4, fig.width=2.5}
cols <- colorRampPalette(c("blue","white","red"))(99)
brks <- seq(-log(10), log(10), length=100)/log(2)
genes1 <- c("Prok2", "Nos2", "Teddm3", "Lipg", "Saa3", "Wfdc17", "Cd38", "Ggt1", "Dpep2", "Mmp19")
pheatmap(t(neutrophils_pois_mash_ruv_fit$result$PosteriorMean[genes1, idx.trts])/log(2), cluster_rows = FALSE, cluster_cols = FALSE, color = cols, breaks = brks, angle_col = 90, fontsize = 7, main = "")
```

Plot a few DE genes that show effect sharing among the second group of
cytokines (taken from Figure 7 in our paper):

```{r plot-lfc-2, fig.height=4, fig.width=2.5}
genes2 <- c("Gbp2", "Gbp3", "Gbp4", "Gbp5", "Ifi47", "Ifit2", "Ifit3", "Socs1", "Tgtp2", "Zbp1")
pheatmap(t(neutrophils_pois_mash_ruv_fit$result$PosteriorMean[genes2, idx.trts])/log(2), cluster_rows = FALSE, cluster_cols = FALSE, color = cols, breaks = brks, angle_col = 90, fontsize = 7, main = "")
```

Session info
------------

This is the version of R and the packages that were used to generate
these results:

```{r session-info}
sessionInfo()
```

[paper]: https://arxiv.org/abs/2210.00697
[software]: https://github.com/stephenslab/poisson.mash.alpha
[mash]: https://dx.doi.org/10.1038/s41588-018-0268-8
[lfsr]: https://doi.org/10.1093/biostatistics/kxw041
[glmpca]: https://github.com/willtownes/glmpca
