---
title: "Multi-condition differential expression analysis in single-cell RNA-seq data using Poisson mash"
author: Yusha Liu, Peter Carbonetto
date: "`r Sys.Date()`"
output:
  html_document:
    toc: no
    highlight: textmate
    theme: readable
vignette: >
  %\VignetteIndexEntry{Multi-condition differential expression analysis in single-cell RNA-seq data using Poisson mash}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = "#",collapse = TRUE,results = "hold",
                      fig.align = "center",dpi = 120)
```

Overview
--------

This vignette illustrates how to use
[Poisson multivariate adaptive shrinkage][paper] to analyze a data
set. Poisson mash was developed for multi-condition differential
expression analysis with single-cell RNA-sequencing (scRNA-seq) data in
which gene expression is measured in many (e.g., dozens) of different
conditions. The aim is to detect which genes are differentially
expressed (DE) and to estimate expression differences (log-fold
changes) among multiple conditions. This approach makes use of the
multivariate adaptive shrinkage ([mash][mash]) prior.

We illustrate how to implement this approach by analyzing data from an
experiment intended to study the effects of cytokine stimulation on
gene expression in neutrophils collected from cytokine-injected mice.

We first load in the R packages that will be used in the analysis,
then we work through an example to illustrate how to apply Poisson
mash step-by-step.

```{r load-pkgs, message=FALSE, warning=FALSE}
library(Matrix)
library(scran)
library(glmpca)
library(pheatmap)
library(poisson.mash.alpha)
```

Also, set the random number generator seed to ensure that the
results are more reproducible.

```{r set-seed}
set.seed(1)
```

Create a data object for Poisson mash analysis
----------------------------------------------

To run Poisson mash, you need to provide (1) a matrix of UMI counts,
stored as a $J \times N$ matrix $Y$ with entries $y_{ji}$, where $i =
1, \dots,N$ indexes cells and $j=1,\dots,J$ indexes genes; and (2) an
vector of length $n$ in which the $i^{\mathrm{th}}$ element gives the
condition label of cell $i$. We assume that the $N$ cells come from
$R$ conditions (in practice, $R$ should be considerably larger than
2).

The original neutrophils dataset contained counts for 13,362 cells,
8,543 genes and 45 conditions (44 cytokine treatments plus one
control). For the purposes of illustrating the interface, we use a
small subset of these data (1,936 cells, 2,158 genes, 12 conditions),
but later we examine the results from running Poisson mash on the full
data.

```{r load-data}
data(neutrophils_subset)
dim(Y)
conditions <- as.factor(conditions)
table(conditions)
```
 
After loading in the data, we compute the cell-specific size factors.
This can be done in various ways. The simplest option is to take the
sum of the counts $y_{ji}$ across all genes in each cell $i$. Here
we take a deconvolution-based approach that was implemented in the
scran package:

```{r calculate-size-factor}
clusters  <- quickCluster(Y)
si        <- calculateSumFactors(Y,clusters = clusters)
names(si) <- colnames(Y)
```

Next, we create a data object for poisson mash analysis using the
function `pois_mash_set_data`.

```{r create-data-object}
dat <- pois_mash_set_data(Y,conditions,si)
```

By default, Poisson mash assumes a gene-specific baseline expression
level, $\mu_j$, shared across all conditions. Poisson mash can also
handle the more complex setting in which the $R$ conditions arise from
$m = 1, \dots, M$ subgroups, and each subgroup has its own baseline,
$\mu_{jm}$. For example, one may want to perform a DE analysis across
multiple treatment conditions, jointly for multiple cell types. In
this case, $M$ is the number of cell types, and $R$ represents the
total number of combinations of treatment conditions and cell
types. Please refer to the documentation for the function
`pois_mash_set_data` to see how to do this.

Estimate latent factors capturing unwanted variation
----------------------------------------------------

Unwanted variation present in the data can induce dependence among
gene-wise tests and confound DE analysis. In some cases, the
confounding variables are known, such as when these capture batch
effects. More often, the unwanted variation is due to unmeasured
factors. Here we estimating the confounding variables using
[glmpca][glmpca].

```{r ruv}
design <- model.matrix(~conditions)
fit.glmpca <- glmpca(Y = as.matrix(Y),X = design[,-1],L  = 4,fam = "nb2",
                     sz = si,ctl = list(minIter = 1,maxIter = 20,
                                        verbose = TRUE))
Fuv <- as.matrix(fit.glmpca$loadings)
```

To save time, we ran `glmpca` for only 20 iterations, but typically
more iterations will be needed (100, or perhaps more).

Fit the Poisson mash model
--------------------------

### Step 1: Prefit the model to initialize parameters

We first fit Poisson mash under the assumption of no DE to get
sensible initial estimates of the other model parameters, including
the gene-specific baseline expressions $\mu_j$. Please refer to the
[paper][paper] for details.

```{r prefit}
prefit <- pois_mash_prefit(dat,ruv = TRUE,Fuv = Fuv,verbose = FALSE)
```

### Step 2: Set up the prior covariance matrices

Let the $R \times 1$ vector $\beta_j = (\beta_{j1}, \dots,
\beta_{jR})'$ denote the true DE effects of each of the $R$ conditions
relative to the baseline expression $\mu_j$ for gene $j$. We assume
that $\beta_j$ follows a mash prior, which is a mixture of
multivariate normal distributions: $$ p(\beta_j; \pi, U) =
\sum_{k=1}^K \sum_{l=1}^L \pi_{kl} N_R(\beta_j; 0, w_l U_k).$$ In the
mash prior, $w_l$ is a pre-specified grid of scaling coefficients,
spanning from very small to very large, to capture the full range of
possible DE effect sizes; $U_k$ is a set of covariance matrices, each
of which capturing a different pattern of covariation of DE effects
across conditions; $\pi_{kl}$ are corresponding mixture proportions
that are estimated from the data during model fitting.

To use Poisson mash, you need to specify the prior covariance
matrices. This may include "canonical" covariance matrices that
represent, for example, DE specific to a condition; and "data-driven"
covariance matrices that are learned from the data and can capture
arbitrary patterns of DE among conditions.

For the canonical matrices, here we consider the matrices capturing
condition-specific effects for each of the $R$ conditions. These
matrices can be generate using the function `pois_cov_canonical`.

```{r canonical}
ulist.c <- pois_cov_canonical(dat)
```

Data-driven covariance matrices are estimated using a three-step
process: (1) initialization, (2) refinement, (3) diagonal entry
modification. The initialization phase is implemented by the function
`pois_cov_init`. To estimate data-driven covariance matrices, we only
use the subset of genes containing "strong signals"; that is, the
genes that are considered DE by a multinomial goodness-of-fit test.
The selection of genes with strong signals is implicitly performed
by the call to `pois_cov_init`, e.g., setting `cutoff = 3` selects
the genes for which the magnitude of $Z$-score (inverted from the 
$p$-value of the goodness-of-fit test) exceeds 3. 

```{r cov-init}
res.pca <- pois_cov_init(dat, cutoff = 3)
```

The refinement phase refines the initial estimates of data-driven
covariance matrices using the Extreme Eeconvolution (ED) algorithm,
and is implemented by the function `pois_cov_ed`. As in the
initialization phase, only data from the genes with strong signals are
used. It should be noted that only data-driven covariance matrices
need to be refined, so they need to be distinguished from the canonical
covariance matrices in the `pois_cov_ed` call using the argument 
`ulist.dd`. For the purposes of this vignette, we just ran `pois_cov_ed` 
for 10 iterations, but we recommend using the default value `maxiter =
500` when analyzing your own data.

```{r cov-ed}
R <- ncol(dat$X)
# Merge data-driven and canonical rank-1 prior covariance matrices
ulist <- c(res.pca$ulist,ulist.c)
# Specify whether a rank-1 prior covariance matrix is data-driven or not
# (note all full-rank covariance matrices are data-driven so do not need this specification)
ulist.dd <- c(rep(TRUE,length(res.pca$ulist) - 1),rep(FALSE,R + 1)) 
# Run ED on the genes with strong signals.
fit.ed <- pois_cov_ed(dat,subset = res.pca$subset,Ulist = res.pca$Ulist,
                      ulist = ulist,ulist.dd = ulist.dd,ruv = TRUE,
					  Fuv = Fuv,verbose = TRUE,init = prefit,
					  control = list(maxiter = 10))
```

The modification phase adds a small constant $\epsilon^2$ (e.g., $0.01$) 
to the diagonal entries of the estimated data-driven covariance
matrices. This step is done to alleviate issues of inflated
[local false sign rates (lfsr)][lfsr], which are analogous to but 
more conservative than local false discovery rates. Similarly, only 
data-driven covariance matrices require such modification, and 
this information is encoded in the vector `epsilon2.G` and 
will be passed to the function call in the next step.

```{r cov-mod}
# add epsilon2*I to each full-rank data-driven prior covariance matrix
# all the full-rank covariance matrices are data-driven and need this modification
Ulist <- fit.ed$Ulist
H <- length(Ulist)
for(h in 1:H){
  Uh <- Ulist[[h]]
  Uh <- Uh/max(diag(Uh))
  Ulist[[h]] <- Uh + 1e-2*diag(R)
}

# add epsilon2*I to each rank-1 data-driven prior covariance matrix
# only a subset of the rank-1 covariance matrices are data-driven and need this modification
G <- length(fit.ed$ulist)
epsilon2.G <- rep(1e-8, G)
names(epsilon2.G) <- names(fit.ed$ulist)
epsilon2.G[ulist.dd] <- 1e-2
```

### Step 3: Fit the Poisson mash model

Now we are ready to fit the Poisson mash model to data from all genes,
which is implemented by the function `pois_mash`. For the purposes of
this illustration, we only run `pois_mash` for 10 iterations, but we
in practice recommend setting `maxiter = 100` (or more) when
analyzing your own data.

```{r fit-model}
res <- pois_mash(data = dat,Ulist = Ulist,ulist = fit.ed$ulist,
                 ulist.epsilon2 = epsilon2.G,gridmult = 2.5,ruv = TRUE,
				 Fuv = Fuv,rho = prefit$rho,verbose = TRUE,
				 init = list(mu = prefit$mu,psi2 = prefit$psi2),
				 control = list(maxiter = 10,nc = 2)) 
```

Poisson mash aims to detect and estimate expression differences
relative to some "reference" condition, which needs to be specified by
the user. By default, the reference condition is the mean across all
conditions. Alternatively, users can specify a particular condition as
the reference condition using the arguments `C` and `res.colnames` of
the function `pois_mash`. If it is also of interest to detect and
estimate expression differences relative to the median across all
conditions, this can be accomplished by setting `median_deviations =
TRUE` in the above call.

# Examining the results

We will next look at the results, which are stored in the `res` object
produced by the call to `pois_mash`. Recall that we illustrate how to
fit the Poisson mash model using a subset of the neutrophils data to
save time. Here we load in the Poisson mash fit to the entire
neutrophils dataset.

```{r load-results}
data(neutrophils_pois_mash_ruv_fit)
```

The output contains posterior summaries of the condition-specific DE
effects relative to the reference condition specified by the user,
including posterior means and posterior standard deviations of the DE
effect sizes (log-fold changes) and measures of significance (lfsr),
for each gene in the dataset. These DE effect posterior summaries are
stored in the `result` component.

```{r posterior-mean}
# Transform DE effect estimates to the scale of log2 fold change from natural log scale.
res$result$PosteriorMean[1:5,1:5]/log(2)
```

```{r posterior-lfsr}
# Obtain gene-specific, condition-specific lfsr for detecting gene-condition DE effects.
res$result$lfsr[1:5,1:5]
```


We can find the number of DE genes, which are defined as genes having
*lfsr* less than $\alpha$ in at least one condition, where $\alpha$ is a
threshold specified by the user (e.g., 0.05).

```{r find-de}
lfsr <- res$result$lfsr
# Get the indices of identified DE genes.
min.lfsr <- apply(lfsr,1,min)
# Order genes by significance based on mininum lfsr across conditions.
rows <- order(min.lfsr)
lfsr <- lfsr[rows,]
min.lfsr <- min.lfsr[rows]
de.genes <- which(min.lfsr < 0.05)
# Get the total number of DE genes.
length(de.genes)
```

The model parameter estimates are stored in the `pois.mash.fit`
component. In particular, let us look at $\pi_{kl}$, the estimates
of the mixture proportions for combinations of different scaling 
coefficients $w_l$ and prior covariance matrices $U_k$:

```{r mixture-proportion}
pheatmap(res$pois.mash.fit$pi, cluster_rows=FALSE, cluster_cols=FALSE, fontsize_row=6, fontsize_col=6, main="Proportion estimates of prior covariance matrices")
```

The data-driven covariance matrix "tPCA" has by far the largest
proportion estimate (91%; summed over all scaling coefficients). 
We plot the correlation heatmap for this covariance matrix, 
which captures the most frequent pattern of sharing of DE effects 
across cytokine treatments in the neutrophils data. For space reason, 
here we present the correlation heatmap only for selected conditions.

```{r plot-sharing-pattern, fig.height=4, fig.width=4}
data(condition_colors)
U <- res$pois.mash.fit$Ulist[[1]]
colnames(U) <- colnames(res$pois.mash.fit$mu)
rownames(U) <- colnames(res$pois.mash.fit$mu)
idx.trts <- match(names(cols.trt),colnames(res$pois.mash.fit$mu))
corr <- cov2cor(U[idx.trts,idx.trts])
pheatmap(corr,cluster_rows = FALSE,cluster_cols = FALSE,angle_col = 90,
         fontsize = 8,main = "Correlation matrix for\nthe major prior covariance (weight = 91%)")
```

This correlation heatmap suggests strong sharing of DE effects among 
two groups of cytokines (1) IL-1$\alpha$, IL-1$\beta$, G-CSF and 
(2) IL-12 p70, IFN-$\gamma$, IL-18, IL-15, IL-33. We then plot
the log-fold changes for a few DE genes that either show effect 
sharing among (1) or (2), where the reference condition is the mean
across all conditions.

```{r plot-lfc, fig.height=4, fig.width=4}
### define the color map for LFC
cols <- colorRampPalette(c("blue","white","red"))(99)
brks <- seq(-log(10), log(10), length=100)/log(2)

### plot a few DE genes that show effect sharing among the first group of cytokines (taken from Figure 7 in our paper)
genes1 <- c("Prok2", "Nos2", "Teddm3", "Lipg", "Saa3", "Wfdc17", "Cd38", "Ggt1", "Dpep2", "Mmp19")
pheatmap(t(res$result$PosteriorMean[genes1, idx.trts])/log(2), cluster_rows = FALSE, cluster_cols = FALSE, color = cols, breaks = brks, angle_col = 90, main = "")

### plot a few DE genes that show effect sharing among the second group of cytokines (taken from Figure 7 in our paper)
genes2 <- c("Gbp2", "Gbp3", "Gbp4", "Gbp5", "Ifi47", "Ifit2", "Ifit3", "Socs1", "Tgtp2", "Zbp1")
pheatmap(t(res$result$PosteriorMean[genes2, idx.trts])/log(2), cluster_rows = FALSE, cluster_cols = FALSE, color = cols, breaks = brks, angle_col = 90, main = "")
```



Session info
------------

This is the version of R and the packages that were used to generate
these results.

```{r session-info}
sessionInfo()
```

[paper]: https://arxiv.org/abs/2210.00697
[software]: https://github.com/stephenslab/poisson.mash.alpha
[mash]: https://dx.doi.org/10.1038/s41588-018-0268-8
[lfsr]: https://doi.org/10.1093/biostatistics/kxw041
[glmpca]: https://github.com/willtownes/glmpca
